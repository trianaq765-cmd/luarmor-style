const express=require('express'),axios=require('axios'),crypto=require('crypto'),cors=require('cors'),helmet=require('helmet'),rateLimit=require('express-rate-limit'),path=require('path'),fs=require('fs'),config=require('./config'),db=require('./lib/redis'),webhook=require('./lib/webhook');
const app=express(),SESSIONS=new Map(),dynamicWhitelist={userIds:new Set(),hwids:new Set(),ips:new Set()},suspendedUsers={hwids:new Map(),userIds:new Map(),sessions:new Map()};

// === CONSTANTS ===
const BOT_PATTERNS=['python','python-requests','aiohttp','httpx','curl','wget','libcurl','axios','node-fetch','got/','undici','superagent','java/','okhttp','apache-http','go-http','golang','ruby','perl','php/','postman','insomnia','paw/','bot','crawler','spider','scraper','slurp','googlebot','bingbot','yandex','facebookexternalhit','twitterbot','discordbot','telegrambot','burp','fiddler','charles','mitmproxy','nmap','nikto','sqlmap','nuclei','httpie','scanner','checker','monitor','probe'];
const B_HEADERS=['sec-fetch-dest','sec-fetch-mode','sec-fetch-site','sec-ch-ua','sec-ch-ua-mobile','upgrade-insecure-requests'];
const E_HEADERS=['x-hwid','x-roblox-id','x-place-id','x-job-id','x-session-id'];
const ALLOWED_E=['synapse','synapsex','script-ware','scriptware','delta','fluxus','krnl','oxygen','evon','hydrogen','vegax','trigon','comet','solara','wave','zorara','codex','celery','swift','sirhurt','electron','sentinel','coco','temple','valyse','nihon','jjsploit','arceus','roblox','wininet','win32'];

// === UTILITY FUNCTIONS ===
function hmac(d,k){return crypto.createHmac('sha256',k).update(d).digest('hex')}
function secureCompare(a,b){if(typeof a!=='string'||typeof b!=='string'||a.length!==b.length)return false;try{return crypto.timingSafeEqual(Buffer.from(a),Buffer.from(b))}catch{return false}}
function getIP(r){return(r.headers['x-forwarded-for']||'').split(',')[0].trim()||r.headers['x-real-ip']||r.ip||'0.0.0.0'}
function getHWID(r){return r.headers['x-hwid']||null}

// === CLIENT DETECTION ===
function getClientType(req){const ua=(req.headers['user-agent']||'').toLowerCase(),h=req.headers;const eS=E_HEADERS.filter(x=>h[x]).length,bS=B_HEADERS.filter(x=>h[x]).length;if(BOT_PATTERNS.some(p=>ua.includes(p))&&eS===0)return'bot';if(bS>=2)return'browser';if(!ua||ua.length<10)return eS>=2?'executor':'bot';if(eS>=2||ALLOWED_E.some(e=>ua.includes(e)))return'executor';return'unknown'}
async function checkWhitelist(h,u,req){const ip=getIP(req);if(config.WHITELIST_IPS?.includes(ip)||dynamicWhitelist.ips.has(ip))return true;if(u){const uid=parseInt(u);if(config.WHITELIST_USER_IDS?.includes(uid)||dynamicWhitelist.userIds.has(uid))return true}if(h&&(config.WHITELIST_HWIDS?.includes(String(h))||dynamicWhitelist.hwids.has(String(h))))return true;return false}
function shouldBlock(req){if(req.path==='/health')return false;const ip=getIP(req);if(config.WHITELIST_IPS?.includes(ip)||dynamicWhitelist.ips.has(ip))return false;const ua=(req.headers['user-agent']||'').toLowerCase();if(['uptimerobot','uptime-kuma','better uptime'].some(b=>ua.includes(b)))return false;return['bot','browser','unknown'].includes(getClientType(req))}

// === FAKE SCRIPT GENERATOR ===
function genFakeScript(){const rS=(l)=>{const c='abcdefghijklmnopqrstuvwxyz';let s='';for(let i=0;i<l;i++)s+=c[Math.floor(Math.random()*26)];return s};return`--[[ Protected by Shield ]]\nlocal ${rS(8)} = "${rS(32)}"\nerror("Invalid Access",0)`}

// === LOADER ENCRYPTION ===
function encryptLoader(script,key){const kB=Buffer.from(key),sB=Buffer.from(script),enc=[];for(let i=0;i<sB.length;i++)enc.push(sB[i]^kB[i%kB.length]);return Buffer.from(enc).toString('base64')}
function genLoaderKey(req){const c=[req.headers['x-hwid']||'',req.headers['x-roblox-id']||'',req.headers['x-place-id']||'',config.LOADER_KEY||config.SECRET_KEY];return crypto.createHash('md5').update(c.join(':')).digest('hex').substring(0,16)}

// === CHUNKED DELIVERY ===
function chunkString(str,size){const chunks=[];for(let i=0;i<str.length;i+=size)chunks.push(str.substring(i,i+size));return chunks}
function encryptChunk(c,k){const e=[];for(let i=0;i<c.length;i++){const cc=c.charCodeAt(i),kc=k.charCodeAt(i%k.length);e.push((cc^kc)&255)}return e}
function generateChunkKeys(baseKey,count){const keys=[];for(let i=0;i<count;i++)keys.push(crypto.createHash('md5').update(baseKey+':'+i).digest('hex'));return keys}
async function prepareChunks(s,ch){const count=config.CHUNK_COUNT||3,size=Math.ceil(s.length/count),chunks=chunkString(s,size);const base=crypto.createHash('sha256').update((ch.hwid||'')+(ch.userId||'')+config.SECRET_KEY).digest('hex');const keys=generateChunkKeys(base,chunks.length);return{chunks:chunks.map((c,i)=>({index:i,data:encryptChunk(c,keys[i])})),keys,totalChunks:chunks.length}}

// === SUSPEND/KILL SWITCH ===
async function suspendUser(type,value,data){const entry={...data,type,value,suspendedAt:new Date().toISOString(),expiresAt:data.duration?new Date(Date.now()+data.duration*1000).toISOString():null};if(type==='hwid')suspendedUsers.hwids.set(String(value),entry);else if(type==='userId')suspendedUsers.userIds.set(String(value),entry);else if(type==='session')suspendedUsers.sessions.set(String(value),entry);await db.addSuspend(type,String(value),entry);webhook.suspicious({userId:data.userId,hwid:data.hwid,ip:data.ip,reason:'Suspended: '+(data.reason||'Admin action'),tool:'N/A',action:'Suspended'}).catch(()=>{})}
async function unsuspendUser(type,value){if(type==='hwid')suspendedUsers.hwids.delete(String(value));else if(type==='userId')suspendedUsers.userIds.delete(String(value));else if(type==='session')suspendedUsers.sessions.delete(String(value));await db.removeSuspend(type,String(value))}
function checkSuspended(h,u,sid){const now=Date.now();const check=(m,k)=>{if(m.has(k)){const s=m.get(k);if(!s.expiresAt||new Date(s.expiresAt).getTime()>now)return{suspended:true,reason:s.reason||'Suspended'};m.delete(k)}return null};return check(suspendedUsers.sessions,sid)||check(suspendedUsers.hwids,h)||check(suspendedUsers.userIds,String(u))}
async function loadSuspendedFromDB(){const all=await db.getAllSuspends();if(all&&all.length>0){all.forEach(s=>{if(s.type==='hwid')suspendedUsers.hwids.set(s.value,s);else if(s.type==='userId')suspendedUsers.userIds.set(s.value,s);else if(s.type==='session')suspendedUsers.sessions.set(s.value,s)});console.log(`‚úÖ Loaded ${all.length} suspended entries`)}}

// === LOGGING ===
async function logAccess(r,a,s,d={}){const log={ip:getIP(r),hwid:getHWID(r),ua:(r.headers['user-agent']||'').substring(0,100),action:a,success:s,client:getClientType(r),ts:new Date().toISOString(),...d};await db.addLog(log);return log}

// === SCRIPT HANDLING ===
async function getScript(){const c=await db.getCachedScript();if(c)return c;if(!config.SCRIPT_SOURCE_URL)return null;try{const res=await axios.get(config.SCRIPT_SOURCE_URL,{timeout:30000});if(res.data){await db.setCachedScript(res.data);return res.data}}catch(e){console.error('Script fetch error:',e.message)}return null}
function wrapScript(s,serverUrl){const o=(config.OWNER_USER_IDS||[]).join(',');const w=(config.WHITELIST_USER_IDS||[]).join(',');const sid=crypto.randomBytes(16).toString('hex');const antiSpyEnabled=config.ANTI_SPY_ENABLED!==false;const autoBan=config.AUTO_BAN_SPYTOOLS===true;
return`--[[ Script Shield Protection Layer ]]
local _CFG={o={${o}},w={${w}},banUrl="${serverUrl}/api/ban",webhookUrl="${serverUrl}/api/webhook/suspicious",hbUrl="${serverUrl}/api/heartbeat",sid="${sid}",as=${antiSpyEnabled},ab=${autoBan},hbi=45}
local _P=game:GetService("Players") local _L=_P.LocalPlayer local _CG=game:GetService("CoreGui") local _SG=game:GetService("StarterGui") local _H=game:GetService("HttpService") local _A=true local _CON={} local _HB_FAIL=0
local function _n(t,x,d)pcall(function()_SG:SetCore("SendNotification",{Title=t,Text=x,Duration=d or 3})end)end
local function _hw()local s,r=pcall(function()if gethwid then return gethwid()end;if getexecutorname then return getexecutorname()..tostring(_L.UserId)end;return"NK_"..tostring(_L.UserId)end)return s and r or"UNK"end
local function _hp(u,d)local r=(syn and syn.request)or request or http_request or(http and http.request)if not r then return nil end;local s,res=pcall(function()return r({Url=u,Method="POST",Headers={["Content-Type"]="application/json",["User-Agent"]="Roblox/WinInet",["x-hwid"]=_hw(),["x-roblox-id"]=tostring(_L.UserId),["x-session-id"]=_CFG.sid},Body=_H:JSONEncode(d)})end)if not s or not res then return nil end;if res.StatusCode~=200 then return nil end;local ps,pd=pcall(function()return _H:JSONDecode(res.Body)end)return ps and pd or nil end
local function _isW(u)for _,i in ipairs(_CFG.w)do if u==i then return true end end;return false end
local function _isO(u)for _,i in ipairs(_CFG.o)do if u==i then return true end end;return false end
local function _cl(msg)if not _A then return end;_A=false;_n("‚ö†Ô∏è",msg or"Script terminated",3);for i=#_CON,1,-1 do pcall(function()_CON[i]:Disconnect()end)end;task.wait(0.5);_L:Kick(msg or"Session terminated")end
local _SPY_T={"SimpleSpy","HttpSpy","RemoteSpy","Hydroxide","Dex","DarkDex","InfiniteYield","CMD-X","ServerSpy","ScriptDumper"}
local _SPY_G={"simplespy","httpspy","remotespy","hydroxide","dex","darkdex","infiniteyield","cmdx","serverspy"}
local _SNAP_G={} local _SNAP_GL={}
local function _takeSnapshot()local e=getgenv and getgenv()or _G;for _,name in ipairs(_SPY_T)do if rawget(e,name)then _SNAP_GL[name]=true end end;pcall(function()for _,g in pairs(_CG:GetChildren())do if g:IsA("ScreenGui")then _SNAP_G[g.Name:lower()]=true end end end)end
local function _detectNewSpy()if _isW(_L.UserId)then return nil end;local e=getgenv and getgenv()or _G;for _,name in ipairs(_SPY_T)do local ok,v=pcall(function()return rawget(e,name)end)if ok and v and not _SNAP_GL[name]then return name end end;pcall(function()for _,g in pairs(_CG:GetChildren())do if g:IsA("ScreenGui")then local n=g.Name:lower()for _,spy in ipairs(_SPY_G)do if n:find(spy)and not _SNAP_G[n]then return g.Name end end end end end)return nil end
local function _startAntiSpy()if not _CFG.as or _isW(_L.UserId)then return end;task.spawn(function()task.wait(2);_takeSnapshot();task.wait(1);_takeSnapshot();while _A do task.wait(20);if not _A then break end;local tool=_detectNewSpy()if tool then pcall(function()_hp(_CFG.webhookUrl,{userId=_L.UserId,hwid=_hw(),tool=tool,sessionId=_CFG.sid})end)if _CFG.ab then pcall(function()_hp(_CFG.banUrl,{hwid=_hw(),playerId=_L.UserId,reason="Spy tool: "..tool,sessionId=_CFG.sid})end)end;_cl("Security violation: "..tool)break end end end)end
local function _startHeartbeat()task.spawn(function()task.wait(10)while _A do local res=_hp(_CFG.hbUrl,{sessionId=_CFG.sid,hwid=_hw(),userId=_L.UserId})if res then _HB_FAIL=0;if res.action=="TERMINATE"then _cl(res.reason or"Session terminated by admin")break elseif res.action=="MESSAGE"and res.message then _n("üì¢",res.message,5)end else _HB_FAIL=_HB_FAIL+1;if _HB_FAIL>=5 then _cl("Connection lost")break end end;task.wait(_CFG.hbi)end end)end
local function _checkOwner()for _,p in pairs(_P:GetPlayers())do if _isO(p.UserId)and p~=_L then return false end end;return true end
local function _startOwnerMonitor()table.insert(_CON,_P.PlayerAdded:Connect(function(p)task.wait(1)if _isO(p.UserId)then _cl("Owner joined server")end end))end
if not _checkOwner()then _n("‚ö†Ô∏è","Owner in server",3)return end
_startOwnerMonitor()
_startAntiSpy()
_startHeartbeat()
${s}`}
function getLoader(url){return`local S="${url}" local H=game:GetService("HttpService") local P=game:GetService("Players") local L=P.LocalPlayer local function n(t,x,d)pcall(function()G:SetCore("SendNotification",{Title=t,Text=x,Duration=d or 3})end)end local function hp(u,d)local r=(syn and syn.request)or request or http_request or(http and http.request)if not r then return nil end;local s,res=pcall(function()return r({Url=u,Method="POST",Headers={["Content-Type"]="application/json",["User-Agent"]="Roblox/WinInet",["x-hwid"]=(gethwid and gethwid() or "UNK"),["x-roblox-id"]=tostring(L.UserId),["x-place-id"]=tostring(game.PlaceId)},Body=H:JSONEncode(d)})end)return (s and res.StatusCode==200) and H:JSONDecode(res.Body) or nil end local function asm(v)if v.mode=="raw" then return v.script end;local p={}for _,c in ipairs(v.chunks)do local k=v.keys[c.index+1]local r={}for i=1,#c.data do r[i]=string.char(bit32.bxor(c.data[i],k:byte((i-1)%#k+1)))end;p[c.index+1]=table.concat(r)end;return table.concat(p)end local c=hp(S.."/api/auth/challenge",{userId=L.UserId,hwid=(gethwid and gethwid() or "UNK"),placeId=game.PlaceId})if c and c.success then local v=hp(S.."/api/auth/verify",{challengeId=c.challengeId,solution=0,timestamp=os.time()})if v and v.success then local f=loadstring(asm(v))if f then pcall(f)end end end`}
function getEncodedLoader(url,req){const key=genLoaderKey(req),enc=encryptLoader(getLoader(url),key);return`local k="${key}"local d="${enc}"local function x(s,k)local r={}local b={}for i=1,#s do b[i]=s:byte(i)end;for i=1,#b do r[i]=string.char(bit32.bxor(b[i],k:byte((i-1)%#k+1)))end;return table.concat(r)end;local function b(s)local t={}local c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"for i=1,64 do t[c:sub(i,i)]=i-1 end;s=s:gsub("[^"..c.."=]","")local r={}local n=1;for i=1,#s,4 do local a,b,c,d=t[s:sub(i,i)]or 0,t[s:sub(i+1,i+1)]or 0,t[s:sub(i+2,i+2)]or 0,t[s:sub(i+3,i+3)]or 0;local v=a*262144+b*4096+c*64+d;r[n]=string.char(bit32.rshift(v,16)%256)n=n+1;if s:sub(i+2,i+2)~="="then r[n]=string.char(bit32.rshift(v,8)%256)n=n+1 end;if s:sub(i+3,i+3)~="="then r[n]=string.char(v%256)n=n+1 end end;return table.concat(r)end;loadstring(x(b(d),k))()`}
const viewsPath=path.join(__dirname,'views'),TRAP_HTML=fs.existsSync(path.join(viewsPath,'trap/index.html'))?fs.readFileSync(path.join(viewsPath,'trap/index.html'),'utf8'):`<!DOCTYPE html><html><head><title>403</title></head><body style="background:#0a0a0f;color:#fff;display:flex;justify-content:center;align-items:center;height:100vh;font-family:sans-serif"><div style="text-align:center"><h1 style="font-size:60px">üõ°Ô∏è</h1><h2 style="color:#ef4444">Access Denied</h2><p style="color:#666">HTTP 403</p></div></body></html>`;
app.use(helmet({contentSecurityPolicy:false,crossOriginEmbedderPolicy:false,crossOriginResourcePolicy:false}),cors({origin:'*',methods:['GET','POST','DELETE','OPTIONS'],allowedHeaders:['Content-Type','x-admin-key','x-hwid','x-roblox-id','x-place-id','x-job-id','x-session-id']}),express.json({limit:'10mb'}));
app.set('trust proxy',1);
app.use(rateLimit({windowMs:60000,max:100,keyGenerator:r=>getIP(r)}));
app.use('/admin/css',express.static(path.join(viewsPath,'admin/css')));
app.use('/admin/js',express.static(path.join(viewsPath,'admin/js')));
app.use(async(req,res,next)=>{const ban=await db.isBanned(null,getIP(req),null);if(ban.blocked){const ct=getClientType(req);if(ct==='browser')return res.status(403).type('html').send(TRAP_HTML);return res.status(403).type('text/plain').send(genFakeScript())}next()});
const adminAuth=(req,res,next)=>{const k=req.headers['x-admin-key']||req.query.key;if(!k)return res.status(403).json({success:false,error:'Unauthorized'});if(!config.ADMIN_KEY)return res.status(500).json({success:false,error:'Server misconfigured'});if(!secureCompare(k,config.ADMIN_KEY))return res.status(403).json({success:false,error:'Unauthorized'});next()};
app.get('/admin',(req,res)=>{const f=path.join(viewsPath,'admin/index.html');if(fs.existsSync(f))res.sendFile(f);else res.status(404).send('Not found')});
app.get('/health',(req,res)=>res.json({status:'ok',redis:db.isRedisConnected?.()??false}));
app.get(['/loader','/api/loader.lua','/api/loader','/l'],async(req,res)=>{const ct=getClientType(req),ip=getIP(req),hwid=getHWID(req);await logAccess(req,'LOADER',ct==='executor',{clientType:ct});if(shouldBlock(req)){console.log(`[Loader] Blocked ${ct} from ${ip}`);return res.status(200).type('text/plain').send(genFakeScript())}const userId=req.headers['x-roblox-id'];const isWL=await checkWhitelist(hwid,userId,req);const url=process.env.RENDER_EXTERNAL_URL||`${req.protocol}://${req.get('host')}`;if(config.ENCODE_LOADER!==false&&!isWL){res.type('text/plain').send(getEncodedLoader(url,req))}else{res.type('text/plain').send(getLoader(url))}});
app.post('/api/auth/challenge',async(req,res)=>{const ct=getClientType(req);if(shouldBlock(req))return res.status(403).json({success:false,error:'Access denied'});const{userId,hwid,placeId}=req.body;if(!userId||!placeId)return res.status(400).json({success:false,error:'Missing fields'});if(config.REQUIRE_HWID&&!hwid)return res.status(400).json({success:false,error:'HWID required'});const uid=parseInt(userId),pid=parseInt(placeId);if(isNaN(uid)||isNaN(pid))return res.status(400).json({success:false,error:'Invalid format'});const ip=getIP(req);const isWL=await checkWhitelist(hwid,uid,req);const susp=checkSuspended(hwid,uid,null);if(susp)return res.json({success:false,error:'Suspended: '+susp.reason});if(!isWL){const ban=await db.isBanned(hwid,ip,uid);if(ban.blocked)return res.json({success:false,error:'Banned: '+ban.reason})}if(config.ALLOWED_PLACE_IDS&&config.ALLOWED_PLACE_IDS.length>0&&!config.ALLOWED_PLACE_IDS.includes(pid)&&!isWL){return res.status(403).json({success:false,error:'Game not authorized'})}await logAccess(req,'CHALLENGE',true,{clientType:ct,whitelisted:isWL,userId:uid});const id=crypto.randomBytes(16).toString('hex'),chal={type:'math',puzzle:{a:0,b:0,op:'+'},answer:0};await db.setChallenge(id,{id,userId:uid,hwid:hwid||'none',placeId:pid,ip,whitelisted:isWL,...chal},120);res.json({success:true,challengeId:id,type:chal.type,puzzle:chal.puzzle,expiresIn:120})});
app.post('/api/auth/verify',async(req,res)=>{const ct=getClientType(req);if(shouldBlock(req))return res.status(403).json({success:false,error:'Access denied'});const{challengeId,solution,timestamp}=req.body;if(!challengeId||solution===undefined||!timestamp)return res.status(400).json({success:false,error:'Missing fields'});const challenge=await db.getChallenge(challengeId);if(!challenge)return res.status(403).json({success:false,error:'Challenge expired'});if(challenge.ip!==getIP(req))return res.status(403).json({success:false,error:'IP mismatch'});if(parseInt(solution)!==challenge.answer)return res.status(403).json({success:false,error:'Wrong solution'});await db.deleteChallenge(challengeId);const script=await getScript();if(!script)return res.status(500).json({success:false,error:'Script not configured'});const url=process.env.RENDER_EXTERNAL_URL||`${req.protocol}://${req.get('host')}`;const wrapped=wrapScript(script,url);const sessionId=crypto.randomBytes(16).toString('hex');SESSIONS.set(sessionId,{hwid:challenge.hwid,ip:challenge.ip,userId:challenge.userId,placeId:challenge.placeId,created:Date.now(),lastSeen:Date.now()});webhook.execution({userId:challenge.userId,hwid:challenge.hwid,placeId:challenge.placeId,ip:challenge.ip,executor:req.headers['user-agent']}).catch(()=>{});await logAccess(req,'VERIFY_SUCCESS',true,{userId:challenge.userId});if(config.CHUNK_DELIVERY==='false'||challenge.whitelisted){const isObf=false;return res.json({success:true,mode:'raw',script:wrapped,sessionId})}const ckd=await prepareChunks(wrapped,challenge);return res.json({success:true,mode:'chunked',chunks:ckd.chunks,keys:ckd.keys,sessionId:sessionId})});
app.post('/api/heartbeat',async(req,res)=>{const{sessionId,hwid,userId}=req.body;if(!sessionId)return res.json({success:true,action:'CONTINUE'});const session=SESSIONS.get(sessionId);if(session)session.lastSeen=Date.now();const sp=checkSuspended(hwid,userId,sessionId);if(sp)return res.json({success:false,action:'TERMINATE',reason:sp.reason});const ban=await db.isBanned(hwid,getIP(req),userId);if(ban.blocked)return res.json({success:false,action:'TERMINATE',reason:'Banned: '+ban.reason});res.json({success:true,action:'CONTINUE'})});
app.post('/api/webhook/suspicious',async(req,res)=>{const{userId,hwid,tool,sessionId}=req.body;await logAccess(req,'SUSPICIOUS',false,{userId,hwid,tool});webhook.suspicious({userId,hwid,ip:getIP(req),reason:'Spy tool detected',tool,action:config.AUTO_BAN_SPYTOOLS?'Auto-banned':'Kicked'}).catch(()=>{});res.json({success:true})});
app.post('/api/ban',async(req,res)=>{const{hwid,playerId,reason,sessionId}=req.body;if(!hwid&&!playerId)return res.status(400).json({error:'Missing id'});const banId=crypto.randomBytes(8).toString('hex').toUpperCase();const banData={ip:getIP(req),reason:reason||'Auto',banId,ts:new Date().toISOString()};if(hwid)await db.addBan(hwid,{hwid,...banData});if(playerId)await db.addBan(String(playerId),{playerId,...banData});if(sessionId)SESSIONS.delete(sessionId);await logAccess(req,'BAN_ADDED',true,{hwid,playerId,reason});webhook.ban({userId:playerId,hwid,ip:getIP(req),reason,bannedBy:'System',banId}).catch(()=>{});res.json({success:true,banId})});
app.get('/api/admin/stats',adminAuth,async(req,res)=>{try{const s=await db.getStats();res.json({success:true,stats:s,sessions:SESSIONS.size,ts:new Date().toISOString()})}catch(e){res.status(500).json({success:false,error:'Failed'})}});
app.get('/api/admin/logs',adminAuth,async(req,res)=>{const l=await db.getLogs(50);res.json({success:true,logs:l})});
app.get('/api/admin/bans',adminAuth,async(req,res)=>{const b=await db.getAllBans();res.json({success:true,bans:b})});
app.post('/api/admin/bans',adminAuth,async(req,res)=>{const{hwid,ip,playerId,reason}=req.body;if(!hwid&&!ip&&!playerId)return res.status(400).json({success:false,error:'Required'});const banId=crypto.randomBytes(8).toString('hex').toUpperCase();const data={reason:reason||'Manual',banId,ts:new Date().toISOString()};if(hwid)await db.addBan(hwid,{hwid,...data});if(playerId)await db.addBan(String(playerId),{playerId,...data});if(ip)await db.addBan(ip,{ip,...data});webhook.ban({userId:playerId,hwid,ip,reason,bannedBy:'Admin',banId}).catch(()=>{});res.json({success:true,banId})});
app.delete('/api/admin/bans/:id',adminAuth,async(req,res)=>{const r=await db.removeBanById(req.params.id);res.json({success:r})});
app.post('/api/admin/bans/clear',adminAuth,async(req,res)=>{const count=await db.clearBans();res.json({success:true,cleared:count})});
app.post('/api/admin/cache/clear',adminAuth,async(req,res)=>{await db.setCachedScript(null);res.json({success:true})});
app.post('/api/admin/sessions/clear',adminAuth,async(req,res)=>{const count=SESSIONS.size;SESSIONS.clear();res.json({success:true,cleared:count})});
app.get('/api/admin/whitelist',adminAuth,async(req,res)=>{res.json({success:true,whitelist:{userIds:[...(config.WHITELIST_USER_IDS||[]),...Array.from(dynamicWhitelist.userIds)],hwids:[...(config.WHITELIST_HWIDS||[]),...Array.from(dynamicWhitelist.hwids)],ips:[...(config.WHITELIST_IPS||[]),...Array.from(dynamicWhitelist.ips)],owners:config.OWNER_USER_IDS||[]}})});
app.post('/api/admin/whitelist',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing fields'});if(type==='userId')dynamicWhitelist.userIds.add(parseInt(value));else if(type==='hwid')dynamicWhitelist.hwids.add(String(value));else if(type==='ip')dynamicWhitelist.ips.add(String(value));else return res.status(400).json({success:false,error:'Invalid type'});res.json({success:true,msg:`Added ${type}: ${value}`})});
app.post('/api/admin/whitelist/remove',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing fields'});if(type==='userId')dynamicWhitelist.userIds.delete(parseInt(value));else if(type==='hwid')dynamicWhitelist.hwids.delete(String(value));else if(type==='ip')dynamicWhitelist.ips.delete(String(value));res.json({success:true,msg:`Removed ${type}: ${value}`})});
app.get('/api/admin/suspended',adminAuth,async(req,res)=>{const a=[];suspendedUsers.hwids.forEach((v,k)=>a.push({type:'hwid',value:k,...v}));suspendedUsers.userIds.forEach((v,k)=>a.push({type:'userId',value:k,...v}));suspendedUsers.sessions.forEach((v,k)=>a.push({type:'session',value:k,...v}));res.json({success:true,suspended:a})});
app.post('/api/admin/suspend',adminAuth,async(req,res)=>{const{type,value,reason,duration}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing type or value'});if(!['hwid','userId','session'].includes(type))return res.status(400).json({success:false,error:'Invalid type'});const d={reason:reason||'Suspended by admin',suspendedAt:new Date().toISOString(),expiresAt:duration?new Date(Date.now()+parseInt(duration)*1000).toISOString():null};if(type==='hwid')suspendedUsers.hwids.set(String(value),d);else if(type==='userId')suspendedUsers.userIds.set(String(value),d);else if(type==='session')suspendedUsers.sessions.set(String(value),d);await db.addSuspend(type,String(value),d);res.json({success:true,msg:`Suspended ${type}: ${value}${duration?' for '+duration+'s':' permanently'}`})});
app.post('/api/admin/unsuspend',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing fields'});if(type==='hwid')suspendedUsers.hwids.delete(String(value));else if(type==='userId')suspendedUsers.userIds.delete(String(value));else if(type==='session')suspendedUsers.sessions.delete(String(value));await db.removeSuspend(type,String(value));res.json({success:true,msg:`Unsuspended ${type}: ${value}`})});
app.post('/api/admin/kill-session',adminAuth,async(req,res)=>{const{sessionId,reason}=req.body;if(!sessionId)return res.status(400).json({success:false,error:'Missing sessionId'});const session=SESSIONS.get(sessionId);if(!session)return res.status(404).json({success:false,error:'Session not found'});await suspendUser('session',sessionId,{reason:reason||'Killed by admin',userId:session.userId,hwid:session.hwid,ip:session.ip});res.json({success:true,msg:'Session will be terminated on next heartbeat'})});
app.get('/api/admin/sessions',adminAuth,async(req,res)=>{const arr=[];SESSIONS.forEach((v,k)=>arr.push({sessionId:k,...v,age:Math.floor((Date.now()-v.created)/1000)}));res.json({success:true,sessions:arr.sort((a,b)=>b.created-a.created)})});
app.use('*',(req,res)=>{const ct=getClientType(req);if(ct==='browser')return res.status(404).type('html').send(TRAP_HTML);res.status(403).type('text/plain').send(genFakeScript())});
setInterval(()=>{const now=Date.now();for(const[k,v]of SESSIONS)if(now-v.lastSeen>7200000)SESSIONS.delete(k);const checkExpiry=(m)=>{for(const[k,v]of m)if(v.expiresAt&&new Date(v.expiresAt).getTime()<now)m.delete(k)};checkExpiry(suspendedUsers.hwids);checkExpiry(suspendedUsers.userIds);checkExpiry(suspendedUsers.sessions)},300000);
const PORT=process.env.PORT||config.PORT||3000;
loadSuspendedFromDB().then(()=>{webhook.serverStart().catch(()=>{});app.listen(PORT,'0.0.0.0',()=>{console.log(`\nüõ°Ô∏è Script Shield v2.0 running on port ${PORT}\nüìç Admin: http://localhost:${PORT}/admin\nüì¶ Loader: http://localhost:${PORT}/loader\n`)})});
