const express=require('express'),axios=require('axios'),crypto=require('crypto'),cors=require('cors'),helmet=require('helmet'),rateLimit=require('express-rate-limit'),path=require('path'),fs=require('fs'),config=require('./config'),db=require('./lib/redis');
const app=express();
app.set('trust proxy',1);
const SESSIONS=new Map(),dynamicWhitelist={userIds:new Set(),hwids:new Set(),ips:new Set()},suspendedUsers={hwids:new Map(),userIds:new Map(),sessions:new Map()};
let keepAliveStats={count:0,lastPing:null,lastService:null,history:[]};
const DISCORD_WEBHOOK_URL=process.env.DISCORD_WEBHOOK_URL||config.DISCORD_WEBHOOK_URL||config.DISCORD_WEBHOOK||null;
const PUBLIC_URL=process.env.PUBLIC_URL||process.env.RENDER_EXTERNAL_URL||null;
const CRON_SERVICES=['uptimerobot','uptime-kuma','better uptime','betteruptime','cron-job.org','cron-job','easycron','pingdom','site24x7','statuscake','freshping','hetrixtools','updown.io','cronitor','healthchecks.io','pulsetic','ohdear','hyperping','montastic','nodeping','uptrends','monitis','alertra','dotcom-monitor','appbeat','checkly','cronhub','deadmanssnitch','healthchecks','oncall','opsgenie','pagerduty','runscope','assertible','apimetrics','loader.io','blazemeter','gtmetrix','webpagetest','render','railway','vercel','netlify','heroku','aws','google','azure','cloudflare'];
const BOT_PATTERNS=['python','python-requests','aiohttp','httpx','curl','wget','libcurl','axios','node-fetch','got/','undici','superagent','java/','okhttp','apache-http','go-http','golang','ruby','perl','php/','postman','insomnia','paw/','bot','crawler','spider','scraper','slurp','googlebot','bingbot','yandex','facebookexternalhit','twitterbot','discordbot','telegrambot','burp','fiddler','charles','mitmproxy','nmap','nikto','sqlmap','nuclei','httpie','scanner','checker','monitor','probe'];
const B_HEADERS=['sec-fetch-dest','sec-fetch-mode','sec-fetch-site','sec-ch-ua','sec-ch-ua-mobile','upgrade-insecure-requests'];
const ALLOWED_E=['synapse','synapsex','script-ware','scriptware','delta','fluxus','krnl','oxygen','evon','hydrogen','vegax','trigon','comet','solara','wave','zorara','codex','celery','swift','sirhurt','electron','sentinel','coco','temple','valyse','nihon','jjsploit','arceus','roblox','wininet','win32'];
const KEEPALIVE_PATHS=['/health','/ping','/api/keepalive','/api/ping','/keepalive','/_health','/healthz','/ready','/live'];
function getPublicUrl(req){return PUBLIC_URL||`${req.protocol}://${req.get('host')}`}
function hmac(d,k){return crypto.createHmac('sha256',k).update(d).digest('hex')}
function secureCompare(a,b){if(typeof a!=='string'||typeof b!=='string'||a.length!==b.length)return false;try{return crypto.timingSafeEqual(Buffer.from(a),Buffer.from(b))}catch{return false}}
function getIP(r){
const cf=r.headers['cf-connecting-ip'];
if(cf)return cf.split(',')[0].trim();
const xff=r.headers['x-forwarded-for'];
if(xff)return xff.split(',')[0].trim();
return r.headers['x-real-ip']||r.ip||'0.0.0.0';
}
function getHWID(r){return r.headers['x-hwid']||null}
function genSessionKey(u,h,t,s){return hmac(`${u}:${h}:${t}`,s).substring(0,32)}
function isKeepAlivePath(p){return KEEPALIVE_PATHS.includes(p)||p.startsWith('/api/keepalive')}
function isCronService(req){const ua=(req.headers['user-agent']||'').toLowerCase();if(CRON_SERVICES.some(s=>ua.includes(s)))return{isCron:true,service:CRON_SERVICES.find(s=>ua.includes(s)),method:'user-agent'};const ch=req.headers['x-cron-service']||req.headers['x-uptime-service'];if(ch)return{isCron:true,service:ch,method:'header'};const cs=r.headers['x-cron-secret']||req.query.cron_secret;if(cs&&config.CRON_SECRET&&cs===config.CRON_SECRET)return{isCron:true,service:'authenticated',method:'secret'};return{isCron:false,service:null,method:null}}
function getClientType(req){const ua=(req.headers['user-agent']||'').toLowerCase(),h=req.headers;if(h['x-hwid']||h['x-roblox-id']||h['x-place-id'])return'executor';if(ALLOWED_E.some(e=>ua.includes(e)))return'executor';if(ua.includes('roblox')||ua.includes('wininet'))return'executor';if(BOT_PATTERNS.some(p=>ua.includes(p)))return'bot';const bS=B_HEADERS.filter(x=>h[x]).length;if(bS>=2)return'browser';if(!ua||ua.length<10)return'unknown';return'unknown'}
async function checkWhitelist(h,u,req){const ip=getIP(req);if(config.WHITELIST_IPS?.includes(ip)||dynamicWhitelist.ips.has(ip))return true;if(u){const uid=parseInt(u);if(config.WHITELIST_USER_IDS?.includes(uid)||dynamicWhitelist.userIds.has(uid))return true}if(h&&(config.WHITELIST_HWIDS?.includes(String(h))||dynamicWhitelist.hwids.has(String(h))))return true;return false}
function genFakeScript(){const rS=l=>{const c='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';let s='';for(let i=0;i<l;i++)s+=c[Math.floor(Math.random()*c.length)];return s},rH=l=>{let h='';for(let i=0;i<l;i++)h+=Math.floor(Math.random()*16).toString(16);return h};return`--[[ Protected by Script Shield v2.0 | Hash: ${rH(32)} ]]\nlocal ${rS(6)} = "${rS(32)}";\nlocal ${rS(5)} = function(${rS(4)})\n return string.byte(${rS(4)}) * ${Math.floor(Math.random()*100)};\nend;\n--[[ Obfuscation applied ]]`}
function encryptLoader(script,key){const kB=Buffer.from(key),sB=Buffer.from(script),enc=[];for(let i=0;i<sB.length;i++)enc.push(sB[i]^kB[i%kB.length]);return Buffer.from(enc).toString('base64')}
function genLoaderKey(req){const c=[req.headers['x-hwid']||'',req.headers['x-roblox-id']||'',req.headers['x-place-id']||'',config.LOADER_KEY||config.SECRET_KEY];return crypto.createHash('md5').update(c.join(':')).digest('hex').substring(0,16)}
function chunkString(str,size){const chunks=[];for(let i=0;i<str.length;i+=size)chunks.push(str.substring(i,i+size));return chunks}
function encryptChunk(c,k){const e=[];for(let i=0;i<c.length;i++){const cc=c.charCodeAt(i),kc=k.charCodeAt(i%k.length);e.push((cc^kc)&255)}return e}
function generateChunkKeys(baseKey,count){const keys=[];for(let i=0;i<count;i++)keys.push(crypto.createHash('md5').update(baseKey+':'+i).digest('hex'));return keys}
async function prepareChunks(s,ch){const count=config.CHUNK_COUNT||3,size=Math.ceil(s.length/count),chunks=chunkString(s,size),base=crypto.createHash('sha256').update((ch.hwid||'')+(ch.userId||'')+config.SECRET_KEY).digest('hex'),keys=generateChunkKeys(base,chunks.length);return{chunks:chunks.map((c,i)=>({index:i,data:encryptChunk(c,keys[i])})),keys,totalChunks:chunks.length}}
async function sendDiscordWebhook(type,data){if(!DISCORD_WEBHOOK_URL)return;const colors={execution:0x00FF00,ban:0xFF0000,suspicious:0xFFA500,serverStart:0x5865F2,info:0x3498DB};const titles={execution:'üéÆ Script Executed',ban:'üö´ User Banned',suspicious:'‚ö†Ô∏è Suspicious Activity',serverStart:'üöÄ Server Started',info:'‚ÑπÔ∏è Info'};try{const embed={title:titles[type]||'üì¢ Notification',color:colors[type]||0x5865F2,fields:[],timestamp:new Date().toISOString(),footer:{text:'Shield v2.3'}};if(data.userId)embed.fields.push({name:'üë§ User ID',value:`\`${data.userId}\``,inline:true});if(data.hwid)embed.fields.push({name:'üîë HWID',value:`\`${String(data.hwid).substring(0,16)}...\``,inline:true});if(data.ip)embed.fields.push({name:'üåê IP',value:`\`${data.ip}\``,inline:true});if(data.placeId)embed.fields.push({name:'üéØ Place ID',value:`\`${data.placeId}\``,inline:true});if(data.reason)embed.fields.push({name:'üìù Reason',value:`\`${data.reason}\``,inline:false});if(data.tool)embed.fields.push({name:'üîß Tool',value:`\`${data.tool}\``,inline:true});if(data.action)embed.fields.push({name:'‚ö° Action',value:`\`${data.action}\``,inline:true});if(data.executor)embed.fields.push({name:'üíª Executor',value:`\`${String(data.executor).substring(0,50)}\``,inline:false});if(data.banId)embed.fields.push({name:'üÜî Ban ID',value:`\`${data.banId}\``,inline:true});if(data.bannedBy)embed.fields.push({name:'üëÆ Banned By',value:`\`${data.bannedBy}\``,inline:true});if(data.message)embed.description=data.message;if(data.stats)embed.fields.push({name:'üìä Stats',value:`Sessions: \`${data.stats.sessions||0}\`\nUptime: \`${data.stats.uptime||'?'}\``,inline:false});await axios.post(DISCORD_WEBHOOK_URL,{embeds:[embed]},{timeout:5000})}catch(e){console.error('Discord webhook error:',e.message)}}
async function suspendUser(type,value,data){const entry={...data,type,value,suspendedAt:new Date().toISOString(),expiresAt:data.duration?new Date(Date.now()+parseInt(data.duration)*1000).toISOString():null};if(type==='hwid')suspendedUsers.hwids.set(String(value),entry);else if(type==='userId')suspendedUsers.userIds.set(String(value),entry);else if(type==='session')suspendedUsers.sessions.set(String(value),entry);await db.addSuspend(type,String(value),entry);sendDiscordWebhook('suspicious',{userId:data.userId,hwid:data.hwid,ip:data.ip,reason:'Suspended: '+(data.reason||'Admin action'),action:'Suspended'}).catch(()=>{})}
function checkSuspended(h,u,sid){const now=Date.now(),check=(m,k)=>{if(m.has(k)){const s=m.get(k);if(!s.expiresAt||new Date(s.expiresAt).getTime()>now)return{suspended:true,reason:s.reason||'Suspended'};m.delete(k)}return null};return check(suspendedUsers.sessions,sid)||check(suspendedUsers.hwids,h)||check(suspendedUsers.userIds,String(u))}
async function loadSuspendedFromDB(){const all=await db.getAllSuspends();if(all&&all.length>0)all.forEach(s=>{if(s.type==='hwid')suspendedUsers.hwids.set(s.value,s);else if(s.type==='userId')suspendedUsers.userIds.set(s.value,s);else if(s.type==='session')suspendedUsers.sessions.set(s.value,s)})}
async function logAccess(r,a,s,d={}){const log={ip:getIP(r),hwid:getHWID(r),ua:(r.headers['user-agent']||'').substring(0,100),action:a,success:s,client:getClientType(r),ts:new Date().toISOString(),...d};await db.addLog(log);return log}
function genChallenge(){const types=['math','bitwise','sequence','sum'],type=types[Math.floor(Math.random()*types.length)];switch(type){case'math':const op=['+','-','*'][Math.floor(Math.random()*3)],a=Math.floor(Math.random()*50)+10,b=Math.floor(Math.random()*20)+5,c=Math.floor(Math.random()*10)+1;let ans;if(op==='+')ans=(a+b)*c;else if(op==='-')ans=(a-b)*c;else ans=(a*b)+c;return{type:'math',puzzle:{a,b,c,op},answer:ans};case'bitwise':const x=Math.floor(Math.random()*200)+50,y=Math.floor(Math.random()*100)+20,bop=['xor','and','or'][Math.floor(Math.random()*3)];let bans;if(bop==='xor')bans=x^y;else if(bop==='and')bans=x&y;else bans=x|y;return{type:'bitwise',puzzle:{x,y,op:bop},answer:bans};case'sequence':const start=Math.floor(Math.random()*15)+1,step=Math.floor(Math.random()*8)+2;return{type:'sequence',puzzle:{seq:[start,start+step,start+step*2,start+step*3]},answer:start+step*4};default:const nums=Array.from({length:5},()=>Math.floor(Math.random()*50)+1);return{type:'sum',puzzle:{numbers:nums},answer:nums.reduce((a,b)=>a+b,0)}}}
async function getScript(){const c=await db.getCachedScript();if(c)return c;if(!config.SCRIPT_SOURCE_URL)return null;try{const res=await axios.get(config.SCRIPT_SOURCE_URL,{timeout:15000});if(res.data){await db.setCachedScript(res.data);return res.data}}catch(e){console.error('Script fetch error:',e.message)}return null}
function isObfuscated(s){if(!s)return false;return[/Luraph/i,/Moonsec/i,/IronBrew/i,/Prometheus/i,/PSU/i].some(r=>r.test(s.substring(0,500)))}
function wrapScript(s,serverUrl){const o=(config.OWNER_USER_IDS||[]).map(id=>`[${id}]=true`).join(','),w=(config.WHITELIST_USER_IDS||[]).map(id=>`[${id}]=true`).join(','),sid=crypto.randomBytes(16).toString('hex'),stoken=crypto.randomBytes(16).toString('hex'),antiSpyEnabled=config.ANTI_SPY_ENABLED!==false;return`--[[Shield v2.3]]\ngetgenv()._SHIELD_SESSION_KEY="${stoken}"\ngetgenv()._SHIELD_TIMESTAMP=${Math.floor(Date.now()/1000)}\nlocal _CFG={o={${o}},w={${w}},wh="${serverUrl}/api/webhook/suspicious",hb="${serverUrl}/api/heartbeat",sid="${sid}",as=${antiSpyEnabled},hbi=45}\nlocal PS=game:GetService("Players")\nlocal CG=game:GetService("CoreGui")\nlocal SG=game:GetService("StarterGui")\nlocal HS=game:GetService("HttpService")\nlocal LP=PS.LocalPlayer\nlocal _A=true\nlocal _C={}\nlocal _HF=0\nlocal _SS={}\nlocal _DC={}\nlocal function NT(t,x,d) pcall(function() SG:SetCore("SendNotification",{Title=t,Text=x,Duration=d or 3}) end) end\nlocal function GH() local s,r=pcall(function() if gethwid then return gethwid() end if getexecutorname then return getexecutorname()..tostring(LP.UserId) end return "NK_"..tostring(LP.UserId) end) return s and r or "UNK" end\nlocal function HP(u,d) local rq=(syn and syn.request)or request or http_request or(http and http.request) if not rq then return end pcall(function() rq({Url=u,Method="POST",Headers={["Content-Type"]="application/json",["User-Agent"]="Roblox/WinInet",["x-hwid"]=GH(),["x-roblox-id"]=tostring(LP.UserId),["x-session-id"]=_CFG.sid},Body=HS:JSONEncode(d)}) end) end\nlocal function IW(u) return _CFG.w[u]==true end\nlocal function IO(u) return _CFG.o[u]==true end\nlocal function TM(r,tn) if not _A then return end _A=false HP(_CFG.wh,{userId=LP.UserId,tool=tn or r,reason=r,sessionId=_CFG.sid,hwid=GH()}) NT("Security",r or "Terminated",3) for i=#_C,1,-1 do pcall(function() _C[i]:Disconnect() end) end task.wait(0.5) pcall(function() if LP.Character then LP.Character:BreakJoints() end end) task.wait(0.5) pcall(function() LP:Kick(r or "Security Violation") end) end\nlocal function IsToolGui(gui) if not gui then return false,nil end local dominated=false pcall(function() if not gui:IsA("ScreenGui") and not gui:IsA("Frame") then return end if gui:FindFirstAncestorOfClass("ScreenGui") then local sg=gui:FindFirstAncestorOfClass("ScreenGui") if sg and sg.Enabled==false then return end end if gui:IsA("ScreenGui") and gui.Enabled==false then return end local n=gui.Name:lower() local dominated_names={"simplespy","remotespy","httpspy","synspy","infiniteyield","infinite_yield","iy_main","iy_fe","dex","dexexplorer","darkdex","hydroxide","remotelogger","scriptdumper"} for _,dn in ipairs(dominated_names) do if n:find(dn) then dominated=true return end end local child_count=0 pcall(function() child_count=#gui:GetDescendants() end) if child_count<3 then return end local has_textbox=false local has_button=false local has_scrollframe=false local has_codelike=false pcall(function() for _,v in pairs(gui:GetDescendants()) do if v:IsA("TextBox") then has_textbox=true end if v:IsA("TextButton") or v:IsA("ImageButton") then has_button=true end if v:IsA("ScrollingFrame") then has_scrollframe=true end if v:IsA("TextLabel") or v:IsA("TextBox") then local txt=(v.Text or ""):lower() if txt:find("remote") or txt:find("fire") or txt:find("invoke") or txt:find("spy") or txt:find("log") or txt:find("function") or txt:find("args") or txt:find("event") then has_codelike=true end end end end) if n:find("spy") or n:find("remote") or n:find("logger") or n:find("dump") then if has_textbox or has_scrollframe then dominated=true end end if n:find("dex") or n:find("explorer") then if has_scrollframe and has_button then dominated=true end end if n:find("iy") or n:find("infinite") or n:find("yield") or n:find("cmd") then if has_textbox and has_button then dominated=true end end if has_codelike and has_scrollframe and has_textbox then dominated=true end end) return dominated,gui.Name end\nlocal function ScanForActiveTools() if not _CFG.as or IW(LP.UserId) then return false,nil end local found=false local toolname=nil pcall(function() for _,gui in pairs(CG:GetChildren()) do if gui:IsA("ScreenGui") and gui.Enabled==true then local ss_name=gui.Name:lower() if _SS[ss_name] then continue end if _DC[ss_name] then continue end local is_tool,name=IsToolGui(gui) if is_tool then found=true toolname=name _DC[ss_name]=true return end end end end) if found then return true,toolname end pcall(function() if LP:FindFirstChild("PlayerGui") then for _,gui in pairs(LP.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") and gui.Enabled==true then local ss_name=gui.Name:lower() if _SS[ss_name] then continue end if _DC[ss_name] then continue end local is_tool,name=IsToolGui(gui) if is_tool then found=true toolname=name _DC[ss_name]=true return end end end end end) if found then return true,toolname end pcall(function() if getnilinstances then for _,inst in pairs(getnilinstances()) do if inst:IsA("ScreenGui") then local ss_name=inst.Name:lower() if _SS[ss_name] then continue end if _DC[ss_name] then continue end local is_tool,name=IsToolGui(inst) if is_tool then found=true toolname=name _DC[ss_name]=true return end end end end end) return found,toolname end\nlocal function TakeSnapshot() pcall(function() for _,gui in pairs(CG:GetChildren()) do if gui:IsA("ScreenGui") then _SS[gui.Name:lower()]=true end end if LP:FindFirstChild("PlayerGui") then for _,gui in pairs(LP.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then _SS[gui.Name:lower()]=true end end end end) end\nlocal function StartMonitor() table.insert(_C,CG.ChildAdded:Connect(function(child) if not _A then return end if not child:IsA("ScreenGui") then return end task.wait(0.5) if not _A then return end local ss_name=child.Name:lower() if _SS[ss_name] then return end if _DC[ss_name] then return end pcall(function() if child.Enabled==true then local is_tool,name=IsToolGui(child) if is_tool then _DC[ss_name]=true TM("Spy Tool Detected: "..name,name) end end end) end)) if LP:FindFirstChild("PlayerGui") then table.insert(_C,LP.PlayerGui.ChildAdded:Connect(function(child) if not _A then return end if not child:IsA("ScreenGui") then return end task.wait(0.5) if not _A then return end local ss_name=child.Name:lower() if _SS[ss_name] then return end if _DC[ss_name] then return end pcall(function() if child.Enabled==true then local is_tool,name=IsToolGui(child) if is_tool then _DC[ss_name]=true TM("Spy Tool Detected: "..name,name) end end end) end)) end task.spawn(function() task.wait(5) while _A do local found,toolname=ScanForActiveTools() if found then TM("Spy Tool Detected: "..toolname,toolname) break end task.wait(5) end end) end\nlocal function COP() for _,p in pairs(PS:GetPlayers()) do if IO(p.UserId) and p~=LP then return false end end return true end\nlocal function SOM() table.insert(_C,PS.PlayerAdded:Connect(function(p) task.wait(1) if IO(p.UserId) and _A then TM("Owner joined","OwnerProtection") end end)) end\nlocal function SHB() task.spawn(function() task.wait(15) while _A do local res local rq=(syn and syn.request)or request or http_request or(http and http.request) if rq then local s,r=pcall(function() return rq({Url=_CFG.hb,Method="POST",Headers={["Content-Type"]="application/json",["x-session-id"]=_CFG.sid},Body=HS:JSONEncode({sessionId=_CFG.sid,hwid=GH(),userId=LP.UserId})}) end) if s and r and r.StatusCode==200 then local ok,bd=pcall(function() return HS:JSONDecode(r.Body) end) if ok then res=bd end end end if res then _HF=0 if res.action=="TERMINATE" then TM(res.reason or "Terminated","Heartbeat") break elseif res.action=="MESSAGE" and res.message then NT("Message",res.message,5) end else _HF=_HF+1 if _HF>=5 then TM("Connection lost","Heartbeat") break end end task.wait(_CFG.hbi) end end) end\nif not COP() then NT("Warning","Owner in server!",5) return end\nTakeSnapshot()\nSOM()\nStartMonitor()\nSHB()\nNT("Shield","Protection active",3)\n${s}`}
function getLoader(url){return`local S="${url}" local H=game:GetService("HttpService") local P=game:GetService("Players") local L=P.LocalPlayer local function n(t,x,d)pcall(function()game:GetService("StarterGui"):SetCore("SendNotification",{Title=t,Text=x,Duration=d or 3})end)end local function hp(u,d)local r=(syn and syn.request)or request or http_request or(http and http.request)if not r then return nil end;local s,res=pcall(function()return r({Url=u,Method="POST",Headers={["Content-Type"]="application/json",["User-Agent"]="Roblox/WinInet",["x-hwid"]=(gethwid and gethwid() or "UNK"),["x-roblox-id"]=tostring(L.UserId),["x-place-id"]=tostring(game.PlaceId)},Body=H:JSONEncode(d)})end) if s and res and res.StatusCode==200 then local ok,body=pcall(function()return H:JSONDecode(res.Body)end) if ok then return body end end return nil end local function xd(data,key)local r={} for i=1,#data do local b=data[i] local k=string.byte(key,((i-1)%#key)+1) table.insert(r, string.char(bit32.bxor(b,k))) end return table.concat(r) end local function sv(p)if not p or not p.type then return 0 end;if p.type=="math"then local a,b,c,op=p.puzzle.a,p.puzzle.b,p.puzzle.c,p.puzzle.op;if op=="+"then return(a+b)*c elseif op=="-"then return(a-b)*c else return(a*b)+c end elseif p.type=="bitwise"then local x,y,op=p.puzzle.x,p.puzzle.y,p.puzzle.op;if op=="xor"then return bit32.bxor(x,y)elseif op=="and"then return bit32.band(x,y)else return bit32.bor(x,y)end elseif p.type=="sequence"then local s=p.puzzle.seq;return s[4]+(s[2]-s[1])elseif p.puzzle and p.puzzle.numbers then local sum=0;for _,x in ipairs(p.puzzle.numbers)do sum=sum+x end;return sum end;return 0 end local function asm(v)if not v then return nil end;if v.mode=="raw" then return v.script end;if v.mode=="chunked" then local p={} for _,c in ipairs(v.chunks) do local k=v.keys[c.index+1] if k and c.data then p[c.index+1]=xd(c.data,k) end end return table.concat(p) end return nil end n("Loading","Connecting...",2) local c=hp(S.."/api/auth/challenge",{userId=L.UserId,hwid=(gethwid and gethwid() or "UNK"),placeId=game.PlaceId}) if c and c.success then n("Loading","Verifying...",2) local v=hp(S.."/api/auth/verify",{challengeId=c.challengeId,solution=sv(c),timestamp=os.time()}) if v and v.success then n("Loading","Loading...",2) local fs=asm(v) if fs then local f,e=loadstring(fs) if f then pcall(f) n("Success","Loaded!",2) else n("Error","Syntax: "..(e or "?"),5) end else n("Error","Assembly Failed",5) end else n("Error","Verify Failed: "..(v and v.error or "Unknown"),5) end else n("Error","Auth Failed: "..(c and c.error or "Connection"),5) end`}
function getEncodedLoader(url,req){const key=genLoaderKey(req),enc=encryptLoader(getLoader(url),key);return`local k="${key}"local d="${enc}"local function x(s,k)local r={}local b={}for i=1,#s do b[i]=s:byte(i)end;for i=1,#b do r[i]=string.char(bit32.bxor(b[i],k:byte((i-1)%#k+1)))end;return table.concat(r)end;local function b(s)local t={}local c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"for i=1,64 do t[c:sub(i,i)]=i-1 end;s=s:gsub("[^"..c.."=]","")local r={}local n=1;for i=1,#s,4 do local a,b,c,d=t[s:sub(i,i)]or 0,t[s:sub(i+1,i+1)]or 0,t[s:sub(i+2,i+2)]or 0,t[s:sub(i+3,i+3)]or 0;local v=a*262144+b*4096+c*64+d;r[n]=string.char(bit32.rshift(v,16)%256)n=n+1;if s:sub(i+2,i+2)~="="then r[n]=string.char(bit32.rshift(v,8)%256)n=n+1 end;if s:sub(i+3,i+3)~="="then r[n]=string.char(v%256)n=n+1 end end;return table.concat(r)end;loadstring(x(b(d),k))()`}
function formatUptime(seconds){const days=Math.floor(seconds/86400),hours=Math.floor((seconds%86400)/3600),mins=Math.floor((seconds%3600)/60),secs=Math.floor(seconds%60);let result='';if(days>0)result+=`${days}d `;if(hours>0)result+=`${hours}h `;if(mins>0)result+=`${mins}m `;result+=`${secs}s`;return result.trim()}
function cleanupExpiredSessions(){const now=Date.now();let cleaned=0;SESSIONS.forEach((session,id)=>{if(now-session.lastSeen>30*60*1000){SESSIONS.delete(id);cleaned++}});return cleaned}
const viewsPath=path.join(__dirname,'views');
const LOADER_HTML=fs.existsSync(path.join(viewsPath,'loader/index.html'))?fs.readFileSync(path.join(viewsPath,'loader/index.html'),'utf8'):`<!DOCTYPE html><html><head><title>Loader</title></head><body style="background:#0a0a0f;color:#fff;display:flex;justify-content:center;align-items:center;height:100vh;font-family:sans-serif"><div style="text-align:center"><h1>üõ°Ô∏è Shield Loader</h1><p style="color:#888">Execute via Roblox executor</p></div></body></html>`;
const TRAP_HTML=fs.existsSync(path.join(viewsPath,'trap/index.html'))?fs.readFileSync(path.join(viewsPath,'trap/index.html'),'utf8'):`<!DOCTYPE html><html><head><title>403</title></head><body style="background:#0a0a0f;color:#fff;display:flex;justify-content:center;align-items:center;height:100vh;font-family:sans-serif"><div style="text-align:center"><h1 style="font-size:60px">üõ°Ô∏è</h1><h2 style="color:#ef4444">Access Denied</h2><p style="color:#666">HTTP 403</p></div></body></html>`;
app.use(helmet({contentSecurityPolicy:false,crossOriginEmbedderPolicy:false,crossOriginResourcePolicy:false}));
app.use(cors({origin:'*',methods:['GET','POST','DELETE','OPTIONS'],allowedHeaders:['Content-Type','x-admin-key','x-hwid','x-roblox-id','x-place-id','x-job-id','x-session-id','x-cron-service','x-cron-secret','x-uptime-service']}));
app.use(express.json({limit:'10mb'}));
app.use(rateLimit({windowMs:60000,max:100,keyGenerator:r=>getIP(r),skip:req=>isKeepAlivePath(req.path)||isCronService(req).isCron}));
app.use('/admin/css',express.static(path.join(viewsPath,'admin/css')));
app.use('/admin/js',express.static(path.join(viewsPath,'admin/js')));
app.use(async(req,res,next)=>{const adminPath=config.ADMIN_PATH||'/admin';if(req.path.startsWith(adminPath)||isKeepAlivePath(req.path))return next();if(req.path==='/loader'||req.path==='/l'||req.path==='/api/loader'||req.path==='/api/loader.lua')return next();const cronCheck=isCronService(req);if(cronCheck.isCron)return next();const ban=await db.isBanned(null,getIP(req),null);if(ban.blocked){const ct=getClientType(req);if(ct==='browser')return res.status(403).type('html').send(TRAP_HTML);return res.status(403).type('text/plain').send(genFakeScript())}next()});
const adminAuth=(req,res,next)=>{const k=req.headers['x-admin-key']||req.query.key;if(!k)return res.status(403).json({success:false,error:'Unauthorized: No key'});if(!config.ADMIN_KEY)return res.status(500).json({success:false,error:'Server misconfigured'});if(!secureCompare(k,config.ADMIN_KEY))return res.status(403).json({success:false,error:'Unauthorized: Invalid key'});next()};
app.get('/ping',(req,res)=>{res.status(200).send('pong')});
app.get('/health',(req,res)=>{res.json({status:'ok',timestamp:new Date().toISOString(),uptime:Math.floor(process.uptime()),redis:db.isRedisConnected?.()??false})});
app.get(['/_health','/healthz','/ready','/live'],(req,res)=>{res.json({status:'ok',timestamp:new Date().toISOString()})});
app.get(['/api/keepalive','/keepalive'],async(req,res)=>{const cronCheck=isCronService(req),ip=getIP(req);keepAliveStats.count++;keepAliveStats.lastPing=new Date().toISOString();keepAliveStats.lastService=cronCheck.service||'Unknown';keepAliveStats.history.unshift({time:keepAliveStats.lastPing,service:keepAliveStats.lastService,ip:ip,method:cronCheck.method});if(keepAliveStats.history.length>10)keepAliveStats.history=keepAliveStats.history.slice(0,10);console.log(`[KeepAlive #${keepAliveStats.count}] ${keepAliveStats.lastPing}`);const cleanedSessions=cleanupExpiredSessions();let dbStatus='unknown';try{await db.getStats();dbStatus='connected'}catch(e){dbStatus='error: '+e.message}res.json({status:'alive',message:'Server is awake!',timestamp:keepAliveStats.lastPing,stats:{pingCount:keepAliveStats.count,uptime:Math.floor(process.uptime()),uptimeFormatted:formatUptime(process.uptime()),memory:Math.round(process.memoryUsage().heapUsed/1024/1024)+'MB',sessions:SESSIONS.size,cleanedSessions},cron:{detected:cronCheck.isCron,service:cronCheck.service,method:cronCheck.method},db:dbStatus,nextSleepIn:'~15 minutes without activity'})});
app.post(['/api/keepalive','/keepalive'],async(req,res)=>{const cronCheck=isCronService(req);keepAliveStats.count++;keepAliveStats.lastPing=new Date().toISOString();keepAliveStats.lastService=cronCheck.service||'POST request';console.log(`[KeepAlive POST #${keepAliveStats.count}] ${keepAliveStats.lastPing}`);cleanupExpiredSessions();res.json({status:'alive',timestamp:keepAliveStats.lastPing,pingCount:keepAliveStats.count})});
const adminPath=config.ADMIN_PATH||'/admin';
app.get(adminPath,(req,res)=>{const f=path.join(viewsPath,'admin/index.html');if(fs.existsSync(f))res.sendFile(f);else res.status(404).send('Admin panel not found')});
app.get(['/loader','/api/loader.lua','/api/loader','/l'],async(req,res)=>{const ct=getClientType(req),ip=getIP(req),hwid=getHWID(req),userId=req.headers['x-roblox-id']||null;const ban=await db.isBanned(hwid,ip,userId);if(ban.blocked){console.log(`[Loader] BANNED - IP: ${ip}, Reason: ${ban.reason}`);await logAccess(req,'LOADER_BANNED',false,{clientType:ct,ip,hwid,userId,banReason:ban.reason});if(ct==='browser')return res.status(403).type('html').send(TRAP_HTML);return res.status(403).type('text/plain').send(genFakeScript())}if(ct==='browser'){console.log(`[Loader] BROWSER - IP: ${ip}`);await logAccess(req,'LOADER_BROWSER',true,{clientType:ct,ip});return res.status(200).type('html').send(LOADER_HTML)}if(ct==='bot'){console.log(`[Loader] BOT - IP: ${ip}, UA: ${req.headers['user-agent']}`);await logAccess(req,'LOADER_BOT_FAKE',false,{clientType:ct,ip});return res.status(200).type('text/plain').send(genFakeScript())}console.log(`[Loader] OK - Type: ${ct}, IP: ${ip}, UserID: ${userId}`);await logAccess(req,'LOADER',true,{clientType:ct,userId});const isWL=await checkWhitelist(hwid,userId,req);const url=getPublicUrl(req);if(config.ENCODE_LOADER!==false&&!isWL)res.type('text/plain').send(getEncodedLoader(url,req));else res.type('text/plain').send(getLoader(url))});
app.post('/api/auth/challenge',async(req,res)=>{const ct=getClientType(req);if(ct==='bot'){await logAccess(req,'CHALLENGE_BLOCKED',false,{clientType:ct});return res.status(403).json({success:false,error:'Access denied'})}const{userId,hwid,placeId}=req.body;if(!userId||!placeId)return res.status(400).json({success:false,error:'Missing userId or placeId'});if(config.REQUIRE_HWID&&!hwid)return res.status(400).json({success:false,error:'HWID required'});const uid=parseInt(userId),pid=parseInt(placeId);if(isNaN(uid)||isNaN(pid))return res.status(400).json({success:false,error:'Invalid format'});const ip=getIP(req);const isWL=await checkWhitelist(hwid,uid,req);const susp=checkSuspended(hwid,uid,null);if(susp)return res.json({success:false,error:'Suspended: '+susp.reason});if(!isWL){const ban=await db.isBanned(hwid,ip,uid);if(ban.blocked)return res.json({success:false,error:'Banned: '+ban.reason})}if(config.ALLOWED_PLACE_IDS&&config.ALLOWED_PLACE_IDS.length>0&&!config.ALLOWED_PLACE_IDS.includes(pid)&&!isWL)return res.status(403).json({success:false,error:'Game not authorized'});await logAccess(req,'CHALLENGE',true,{clientType:ct,whitelisted:isWL,userId:uid});const id=crypto.randomBytes(16).toString('hex');const chal=genChallenge();await db.setChallenge(id,{id,userId:uid,hwid:hwid||'none',placeId:pid,ip,whitelisted:isWL,...chal},120);res.json({success:true,challengeId:id,type:chal.type,puzzle:chal.puzzle,expiresIn:120})});
app.post('/api/auth/verify',async(req,res)=>{const ct=getClientType(req);if(ct==='bot')return res.status(403).json({success:false,error:'Access denied'});const{challengeId,solution,timestamp}=req.body;if(!challengeId||solution===undefined||!timestamp)return res.status(400).json({success:false,error:'Missing fields'});const challenge=await db.getChallenge(challengeId);if(!challenge)return res.status(403).json({success:false,error:'Challenge expired'});const currentIP=getIP(req);if(challenge.ip!==currentIP&&!challenge.whitelisted){console.log(`[Verify] IP mismatch - Expected: ${challenge.ip}, Got: ${currentIP}`);await logAccess(req,'VERIFY_IP_MISMATCH',false,{userId:challenge.userId});return res.status(403).json({success:false,error:'Session expired, please retry'})}if(parseInt(solution)!==challenge.answer){await logAccess(req,'VERIFY_WRONG',false,{userId:challenge.userId});return res.status(403).json({success:false,error:'Verification failed'})}await db.deleteChallenge(challengeId);const script=await getScript();if(!script)return res.status(500).json({success:false,error:'Script not configured'});const url=getPublicUrl(req);const wrapped=wrapScript(script,url);const sessionId=crypto.randomBytes(16).toString('hex');SESSIONS.set(sessionId,{hwid:challenge.hwid,ip:currentIP,userId:challenge.userId,placeId:challenge.placeId,created:Date.now(),lastSeen:Date.now()});sendDiscordWebhook('execution',{userId:challenge.userId,hwid:challenge.hwid,placeId:challenge.placeId,ip:currentIP,executor:req.headers['user-agent']}).catch(()=>{});await logAccess(req,'VERIFY_SUCCESS',true,{userId:challenge.userId});if(config.CHUNK_DELIVERY!==false||challenge.whitelisted){const ckd=await prepareChunks(wrapped,challenge);return res.json({success:true,mode:'chunked',chunks:ckd.chunks,keys:ckd.keys,sessionId})}const isObf=isObfuscated(script)||config.SCRIPT_ALREADY_OBFUSCATED;if(isObf)return res.json({success:true,mode:'raw',script:wrapped,sessionId});const key=genSessionKey(challenge.userId,challenge.hwid,timestamp,config.SECRET_KEY);const chunks=[];for(let i=0;i<wrapped.length;i+=1500){const chunk=wrapped.substring(i,i+1500);const enc=[];for(let j=0;j<chunk.length;j++)enc.push(chunk.charCodeAt(j)^key.charCodeAt(j%key.length));chunks.push(enc)}res.json({success:true,mode:'encrypted',key,chunks,sessionId})});
app.post('/api/heartbeat',async(req,res)=>{const{sessionId,hwid,userId}=req.body;if(!sessionId)return res.json({success:true,action:'CONTINUE'});const session=SESSIONS.get(sessionId);if(session)session.lastSeen=Date.now();const sp=checkSuspended(hwid,userId,sessionId);if(sp)return res.json({success:false,action:'TERMINATE',reason:sp.reason});const ban=await db.isBanned(hwid,getIP(req),userId);if(ban.blocked)return res.json({success:false,action:'TERMINATE',reason:'Banned: '+ban.reason});res.json({success:true,action:'CONTINUE'})});
app.post('/api/webhook/suspicious',async(req,res)=>{const{userId,hwid,tool,sessionId,reason}=req.body;console.log(`[Webhook] SPY DETECTED - User: ${userId}, Tool: ${tool}`);await logAccess(req,'SUSPICIOUS',false,{userId,hwid,tool,reason});sendDiscordWebhook('suspicious',{userId,hwid,ip:getIP(req),reason:reason||'Spy tool: '+tool,tool,action:'Kicked'}).catch(()=>{});res.json({success:true})});
app.post('/api/ban',async(req,res)=>{const{hwid,playerId,reason,sessionId}=req.body;if(!hwid&&!playerId)return res.status(400).json({error:'Missing id'});const banId=crypto.randomBytes(8).toString('hex').toUpperCase();const banData={ip:getIP(req),reason:reason||'Auto',ts:new Date().toISOString()};if(hwid)await db.addBan(hwid,{hwid,...banData,banId});if(playerId)await db.addBan(String(playerId),{playerId,...banData,banId});if(sessionId)SESSIONS.delete(sessionId);console.log(`[Ban] Banned - HWID: ${hwid}, PlayerID: ${playerId}, BanID: ${banId}`);await logAccess(req,'BAN_ADDED',true,{hwid,playerId,reason,banId});sendDiscordWebhook('ban',{userId:playerId,hwid,ip:getIP(req),reason,bannedBy:'System',banId}).catch(()=>{});res.json({success:true,banId})});
app.get('/api/admin/stats',adminAuth,async(req,res)=>{try{const s=await db.getStats();const banCount=await db.getBanCount();res.json({success:true,stats:{...s,bans:banCount},sessions:SESSIONS.size,keepAlive:keepAliveStats,publicUrl:PUBLIC_URL||'not set',ts:new Date().toISOString()})}catch(e){res.status(500).json({success:false,error:'Failed: '+e.message})}});
app.get('/api/admin/keepalive-stats',adminAuth,async(req,res)=>{res.json({success:true,keepAlive:{...keepAliveStats,serverUptime:Math.floor(process.uptime()),serverUptimeFormatted:formatUptime(process.uptime()),memory:process.memoryUsage(),activeSessions:SESSIONS.size}})});
app.get('/api/admin/logs',adminAuth,async(req,res)=>{try{const l=await db.getLogs(50);res.json({success:true,logs:l})}catch(e){res.json({success:false,logs:[],error:e.message})}});
app.post('/api/admin/logs/clear',adminAuth,async(req,res)=>{try{await db.clearLogs();res.json({success:true,message:'Logs cleared'})}catch(e){res.json({success:false,error:e.message})}});
app.get('/api/admin/bans',adminAuth,async(req,res)=>{try{const b=await db.getAllBans();res.json({success:true,bans:b})}catch(e){res.json({success:false,bans:[],error:e.message})}});
app.post('/api/admin/bans',adminAuth,async(req,res)=>{const{hwid,ip,playerId,reason}=req.body;if(!hwid&&!ip&&!playerId)return res.status(400).json({success:false,error:'Required: hwid, ip, or playerId'});const banId=crypto.randomBytes(8).toString('hex').toUpperCase();const data={reason:reason||'Manual ban',banId,ts:new Date().toISOString()};try{if(hwid)await db.addBan(hwid,{hwid,...data});else if(playerId)await db.addBan(String(playerId),{playerId,...data});else if(ip)await db.addBan(ip,{ip,...data});console.log(`[Admin] Banned - banId: ${banId}`);sendDiscordWebhook('ban',{userId:playerId,hwid,ip,reason,bannedBy:'Admin',banId}).catch(()=>{});res.json({success:true,banId,message:'Banned successfully'})}catch(e){res.json({success:false,error:e.message})}});
app.delete('/api/admin/bans/:id',adminAuth,async(req,res)=>{try{const banId=req.params.id;console.log(`[Admin] Removing ban: ${banId}`);const r=await db.removeBanById(banId);if(r){console.log(`[Admin] Ban removed: ${banId}`);res.json({success:true,message:'Ban removed'})}else{console.log(`[Admin] Ban not found: ${banId}`);res.json({success:false,error:'Ban not found'})}}catch(e){console.error(`[Admin] Error:`,e);res.json({success:false,error:e.message})}});
app.post('/api/admin/bans/clear',adminAuth,async(req,res)=>{try{const count=await db.clearBans();res.json({success:true,cleared:count,message:`Cleared ${count} bans`})}catch(e){res.json({success:false,error:e.message})}});
app.post('/api/admin/cache/clear',adminAuth,async(req,res)=>{try{await db.setCachedScript(null);res.json({success:true,message:'Cache cleared'})}catch(e){res.json({success:false,error:e.message})}});
app.post('/api/admin/sessions/clear',adminAuth,async(req,res)=>{const count=SESSIONS.size;SESSIONS.clear();res.json({success:true,cleared:count,message:`Cleared ${count} sessions`})});
app.get('/api/admin/whitelist',adminAuth,async(req,res)=>{res.json({success:true,whitelist:{userIds:[...(config.WHITELIST_USER_IDS||[]),...Array.from(dynamicWhitelist.userIds)],hwids:[...(config.WHITELIST_HWIDS||[]),...Array.from(dynamicWhitelist.hwids)],ips:[...(config.WHITELIST_IPS||[]),...Array.from(dynamicWhitelist.ips)],owners:config.OWNER_USER_IDS||[]}})});
app.post('/api/admin/whitelist',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing type or value'});if(type==='userId')dynamicWhitelist.userIds.add(parseInt(value));else if(type==='hwid')dynamicWhitelist.hwids.add(String(value));else if(type==='ip')dynamicWhitelist.ips.add(String(value));else return res.status(400).json({success:false,error:'Invalid type'});res.json({success:true,msg:`Added ${type}: ${value}`})});
app.post('/api/admin/whitelist/remove',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing fields'});if(type==='userId')dynamicWhitelist.userIds.delete(parseInt(value));else if(type==='hwid')dynamicWhitelist.hwids.delete(String(value));else if(type==='ip')dynamicWhitelist.ips.delete(String(value));res.json({success:true,msg:`Removed ${type}: ${value}`})});
app.get('/api/admin/suspended',adminAuth,async(req,res)=>{const a=[];suspendedUsers.hwids.forEach((v,k)=>a.push({type:'hwid',value:k,...v}));suspendedUsers.userIds.forEach((v,k)=>a.push({type:'userId',value:k,...v}));suspendedUsers.sessions.forEach((v,k)=>a.push({type:'session',value:k,...v}));res.json({success:true,suspended:a})});
app.post('/api/admin/suspend',adminAuth,async(req,res)=>{const{type,value,reason,duration}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing type or value'});if(!['hwid','userId','session'].includes(type))return res.status(400).json({success:false,error:'Invalid type'});const d={reason:reason||'Suspended by admin',suspendedAt:new Date().toISOString(),expiresAt:duration?new Date(Date.now()+parseInt(duration)*1000).toISOString():null};if(type==='hwid')suspendedUsers.hwids.set(String(value),d);else if(type==='userId')suspendedUsers.userIds.set(String(value),d);else if(type==='session')suspendedUsers.sessions.set(String(value),d);await db.addSuspend(type,String(value),d);res.json({success:true,msg:`Suspended ${type}: ${value}${duration?' for '+duration+'s':' permanently'}`})});
app.post('/api/admin/unsuspend',adminAuth,async(req,res)=>{const{type,value}=req.body;if(!type||!value)return res.status(400).json({success:false,error:'Missing fields'});if(type==='hwid')suspendedUsers.hwids.delete(String(value));else if(type==='userId')suspendedUsers.userIds.delete(String(value));else if(type==='session')suspendedUsers.sessions.delete(String(value));await db.removeSuspend(type,String(value));res.json({success:true,msg:`Unsuspended ${type}: ${value}`})});
app.post('/api/admin/kill-session',adminAuth,async(req,res)=>{const{sessionId,reason}=req.body;if(!sessionId)return res.status(400).json({success:false,error:'Missing sessionId'});const session=SESSIONS.get(sessionId);if(!session)return res.status(404).json({success:false,error:'Session not found'});await suspendUser('session',sessionId,{reason:reason||'Killed by admin',userId:session.userId,hwid:session.hwid,ip:session.ip});res.json({success:true,msg:'Session will be terminated on next heartbeat'})});
app.get('/api/admin/sessions',adminAuth,async(req,res)=>{const arr=[];SESSIONS.forEach((v,k)=>arr.push({sessionId:k,...v,age:Math.floor((Date.now()-v.created)/1000)}));res.json({success:true,sessions:arr.sort((a,b)=>b.created-a.created)})});
app.get('/api/admin/script',adminAuth,async(req,res)=>{try{const script=await getScript();if(!script)return res.status(404).json({success:false,error:'No script configured'});res.json({success:true,script,length:script.length,lines:script.split('\n').length,cached:!!(await db.getCachedScript())})}catch(e){res.status(500).json({success:false,error:e.message})}});
app.use('*',(req,res)=>{const ct=getClientType(req);if(ct==='browser')return res.status(404).type('html').send(TRAP_HTML);res.status(403).type('text/plain').send(genFakeScript())});
const PORT=process.env.PORT||config.PORT||3000;
loadSuspendedFromDB().then(()=>{sendDiscordWebhook('serverStart',{message:'Shield server started!',stats:{sessions:SESSIONS.size,uptime:formatUptime(process.uptime())}}).catch(()=>{});app.listen(PORT,'0.0.0.0',()=>{console.log(`\nüõ°Ô∏è Shield v2.3 running on port ${PORT}`);console.log(`üìç Admin: http://localhost:${PORT}${adminPath}`);console.log(`üì¶ Loader: http://localhost:${PORT}/loader`);console.log(`üåê Public URL: ${PUBLIC_URL||'NOT SET'}`);console.log(`üì° Discord Webhook: ${DISCORD_WEBHOOK_URL?'‚úÖ':'‚ùå'}`);console.log(`üî¥ Redis: ${db.isRedisConnected()?'‚úÖ Connected':'‚ùå Using Memory'}`);console.log(`\n`)})});
